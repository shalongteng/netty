#1、为什么要学习I/O
    I/O无处不在，
    本笔记基于网络通信I/O，偏socket

#2、操作系统的I/O
    CPU，内存，硬盘
    内核空间
        保护模式：
            不允许用户程序访问
        切换程序的执行:
            内核使用时钟中断，启动中断处理程序。可以切换程序的执行。
        系统调用：
            软中断（陷阱）(int x80)，会将程序数据写到内存。会有一个切换。
        I/O中断：
            用户读取数据过程中，cpu可以调度其他线程，等io完成以后，发出io中断。
    用户空间
#2、网络通信IO演变过程
    1、BIO
#2、BIO  blocking I/O
    在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的
    I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。 
    
    这个模型最本质的问题在于，严重依赖于线程。
#3、nio Non-blocking I/O
    java写网络程序大多用netty，netty把nio封装了。
    
    利用事件模型处理I/O，解决线程池瓶颈处理海量连接，包括利用面向事件的方式编写服务端/客户端程序。
    Reactor与Proactor模型的对比、Selector的唤醒、Buffer的选择等。
    

#5、IO多路复用技术  
    把多个IO阻塞复用到同一个select阻塞，单线程可以处理多个客户端请求，性能开销小，不需其他的进程或线程，节省资源
